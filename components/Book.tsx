'use client'

import { useState } from 'react'

interface SubSubChapter {
  id: string
  title: string
  content: string
}

interface SubChapter {
  id: string
  title: string
  content?: string
  subSubChapters?: SubSubChapter[]
}

interface Chapter {
  id: number
  title: string
  subChapters: SubChapter[]
}

const chapters: Chapter[] = [
  {
    id: 1,
    title: '코딩의 시작',
    subChapters: [
      {
        id: '1-1',
        title: '바이브코딩이란?',
        content: '바이브 코딩(Vibe Coding)은 전통적인 프로그래밍 방식과 달리, **복잡한 문법이나 언어를 배우지 않고도 AI와 대화만으로 코드를 작성하고 실행할 수 있는 새로운 개발 방식**을 의미합니다.\n\n기존의 코딩은 개발자가 일일이 문법을 이해하고 코드를 작성해야 했습니다. 따라서 진입장벽이 높고, 배우는 데 많은 시간과 노력이 필요했습니다. 반면, 바이브 코딩은 "내가 원하는 결과를 자연어로 설명하면 AI가 알아서 코드를 작성해주는 구조"를 가지고 있어, 코딩 경험이 없는 사람도 얼마든지 결과물을 만들어낼 수 있습니다.\n\n### 1. 왜 \'바이브\' 코딩일까?\n\n\'바이브(Vibe)\'라는 단어는 분위기, 흐름, 감각을 뜻합니다.\n\n바이브 코딩은 이름 그대로, **흐름에 맞춰 AI와 주고받으며 자연스럽게 결과물을 만들어가는 과정**을 강조합니다.\n\n- 내가 아이디어를 말하면 → AI가 코드와 실행 결과를 제시\n- 마음에 들지 않으면 → "이 부분을 더 단순하게 바꿔줘"라고 요청\n- 반복되는 대화를 통해 원하는 결과물을 점점 완성\n\n마치 디자이너와 협업하듯, AI와 대화하면서 작업이 이뤄집니다.\n\n---\n\n### 2. 주요 특징\n\n1. **대화형 개발**: 명령어 대신 대화형 지시로 코드 생성 및 수정\n\n2. **빠른 프로토타입 제작**: 아이디어를 즉시 화면이나 기능으로 구현\n\n3. **낮은 진입장벽**: 프로그래밍 지식 없이도 누구나 시작 가능\n\n4. **AI의 보조**: 오류 수정, 코드 최적화, 새로운 기능 추가 자동 지원\n\n---\n\n### 3. 비개발자에게 주는 가치\n\n바이브 코딩은 특히 **비개발자에게 실질적인 기회**를 제공합니다.\n\n- **부업 수익화**: 홈페이지 제작, 랜딩페이지 제작, 간단한 자동화 프로그램을 만들어 판매 가능\n\n- **시간 절약**: 학습보다 실행에 집중 → 아이디어를 빠르게 실현\n\n- **창업 기회**: 최소 기능 제품(MVP)을 제작하여 시장 반응 검증 가능\n\n- **자기 표현**: 취미, 블로그, 개인 프로젝트 등에도 손쉽게 적용'
      },
      {
        id: '1-2',
        title: '코딩을 위한 준비',
        subSubChapters: [
          {
            id: '1-2-(1)',
            title: '(1) 필수 개념 이해하기',
            content: '1. PRD (Product Requirement Document)\n\n제품 기획 단계에서 "무엇을 만들 것인가"를 정리하는 문서. 초보자라도 실행 전에 방향을 잡는 데 큰 도움이 됩니다.\n\n👉 만들기 전에 방향을 정리하는 지도\n\n2. MCP (Model Context Protocol)\n\nAI가 외부 도구와 연결될 수 있도록 해주는 다리 같은 개념. Cursor 같은 AI 개발 툴에서 활용됩니다.\n\n👉 AI를 더 똑똑하게 만드는 연결 장치\n\n3. LLM (Large Language Model)\n\nChatGPT, Claude, Gemini 같은 AI 기술. 사람의 언어를 코드나 결과물로 바꿔주는 핵심 엔진.\n\n👉 사람의 언어를 이해하는 AI 두뇌\n\n4. 노코드 / 로우코드 (No-code / Low-code)\n\n코드 없이 또는 최소한의 코드로 결과물을 만드는 방식. 러버블(Lovable), 아임웹 같은 서비스가 대표적.\n\n👉 코딩을 몰라도 결과물을 만드는 방법\n\n5. MVP (Minimum Viable Product)\n\n최소 기능만 담은 시제품. 빠른 실행과 시장 검증의 핵심 전략.\n\n👉 작게 시작해서 빠르게 검증\n\n6. API (Application Programming Interface)\n\n결제, 지도, 로그인 같은 기능을 직접 개발하지 않고 가져다 쓰는 연결 통로.\n\n👉 필요한 기능을 쉽게 붙이는 방법\n\n7. 배포 (Deployment)\n\n내 컴퓨터 안에서 만든 것을 세상에 공개하는 과정. Netlify, Vercel, 부스터AI 같은 도구를 통해 간단히 가능.\n\n👉 만든 것을 공개하는 마지막 단계'
          },
          {
            id: '1-2-(2)',
            title: '(2) 필수 사이트 바로가기',
            content: '1. **ChatGPT** — [chat.openai.com](https://chat.openai.com/)\n\n대화형 AI 서비스로, 글쓰기·아이디어 발상·코드 작성 보조까지 가능.\n\n비개발자는 **코드를 직접 작성하기보다 AI에게 설명하고 결과를 얻는 방식**으로 활용할 수 있음.\n\n2. **Claude** — anthropic.com/claude\n\n자연어 이해력이 강하고, 긴 문서를 요약하거나 기획서를 다루는 데 유리함.\n\n비개발자는 **기획 문서 정리, PRD 작성, 아이디어 검증**에 활용하기 좋음.\n\n3. **Gemini** — gemini.google.com\n\n구글의 LLM. 검색·데이터 분석과 연동이 강점.\n\n비개발자는 **시장조사, 최신 자료 검색, 데이터 분석**에 쉽게 활용 가능.\n\n4. **Cursor AI** — [cursor.com](https://cursor.com/?utm_source=chatgpt.com)\n\n개발 친화적인 AI IDE. 코드 작성, 디버깅, 테스트 자동화를 지원.\n\n비개발자는 **"이런 기능 만들어줘"라는 지시만으로 코드 자동 생성** 가능.\n\n5. **Lovable (러버블)** — [lovable.dev](https://lovable.dev/?utm_source=chatgpt.com)\n\n노코드 기반 웹 제작 도구. 드래그 앤 드롭으로 홈페이지 제작 가능.\n\n비개발자는 **홈페이지·랜딩페이지를 직접 제작**할 수 있음.\n\n6. **V0 (by Vercel)** — [v0.app](https://v0.app/)\n\n텍스트 프롬프트로 UI 컴포넌트를 자동 생성하는 AI 빌더.\n\n비개발자는 **간단한 설명만으로 웹 디자인 시안을 바로 뽑아낼 수 있음.**\n\n7. **Supabase** — [supabase.com](https://supabase.com/?utm_source=chatgpt.com)\n\n오픈소스 백엔드 서비스. 로그인, 데이터 저장, 인증 기능 제공.\n\n비개발자는 **회원가입/로그인 기능을 손쉽게 붙이는 용도**로 활용 가능.\n\n8. **Firebase** — firebase.google.com\n\n구글에서 제공하는 백엔드 서비스. 앱 데이터 관리와 푸시 알림에 강점.\n\n비개발자는 **앱이나 프로그램에 데이터 저장, 로그인, 알림 기능 추가**할 때 활용.\n\n9. **부스터AI (Booster AI)** — (예: booster.ai)\n\n간단한 배포와 운영을 돕는 플랫폼.\n\n비개발자는 **자신이 만든 프로젝트를 빠르게 세상에 공개**할 수 있음.\n\n10. **GitHub** — [github.com](https://github.com/)\n\n코드 저장소이자 협업 플랫폼. 버전 관리와 협업에 필수.\n\n비개발자는 **AI가 작성한 코드 저장·공유·배포** 용도로 최소한만 이해해도 충분.'
          },
          {
            id: '1-2-(3)',
            title: '(3) 디자인 참고 사이트',
            content: '- https://21st.dev/home 컴포넌트 벤치마킹\n\n- https://uiverse.io/ 무료로 코드 가져올 수 있음\n\n- https://www.cta.gallery/ 콜투액션 벤츠마킹\n\n- https://www.supahero.io/ 섹션디자인 벤츠마킹\n\n- https://www.footer.design/ 푸터 벤츠마킹\n\n- https://www.navbar.gallery/ 상담네이게이션 디자인 벤치마킹\n\n- https://www.landing.love/ 랜딩페이지 애니메이션 벤치마킹\n\n- https://bentogrids.com/ 레이아웃 벤츠마킹\n\n- https://vibedesignlab.net/ 디자인 패턴 벤츠마킹\n\n- https://mobbin.com/ 종합사례\n\n- https://godly.website/ 종합사례\n\n- https://saaspo.com/ 종합사례'
          },
          {
            id: '1-2-(4)',
            title: '(4) Python과 Node.js 설치하기',
            content: '### Python 설치\n\nPython은 데이터 분석, 웹 개발, 자동화 등 다양한 용도로 사용되는 프로그래밍 언어입니다.\n\n**중요**: Python을 사용하려면 **두 가지를 모두 설치**해야 합니다:\n\n1. **시스템에 Python 런타임 설치** (필수): Python 코드를 실행하기 위해 필요\n2. **커서 AI 마켓플레이스에서 Python 확장 설치** (필수): Python 코드를 편집하고 실행하기 위해 필요\n\n**설치 방법**:\n\n**1단계: 시스템에 Python 설치**\n\n1. **공식 웹사이트 방문**: [python.org](https://www.python.org/downloads/)\n\n2. **다운로드**: 운영체제에 맞는 최신 버전 다운로드 (Python 3.x 권장)\n\n3. **설치**:\n   - Windows: 다운로드한 설치 파일 실행 후 **"Add Python to PATH" 옵션을 반드시 체크**한 후 설치\n   - macOS: 설치 파일 실행 후 안내에 따라 설치\n   - Linux: 대부분 기본 설치되어 있음. 없으면 터미널에서 `sudo apt install python3` 실행\n\n4. **설치 확인**:\n   - 터미널 또는 명령 프롬프트 열기\n   - `python --version` 또는 `python3 --version` 입력\n   - 설치된 버전이 표시되면 성공\n\n**2단계: 커서 AI에서 Python 확장 설치**\n\n1. **확장 프로그램 탭 열기**: `Ctrl + Shift + X` (또는 `Cmd + Shift + X`)\n\n2. **Python 검색**: 검색창에 "Python" 입력\n\n3. **Microsoft Python 확장 설치**: "Python" (Microsoft 제작) 확장 프로그램 설치\n\n4. **설치 확인**: Python 파일(.py)을 열었을 때 자동으로 인식되고 편집 기능이 활성화되면 성공\n\n이 확장 프로그램은 Python 코드 편집, 문법 강조, 자동완성, 디버깅 등을 제공합니다.\n\n---\n\n### Node.js 설치\n\nNode.js는 JavaScript를 서버에서 실행할 수 있게 해주는 런타임 환경입니다.\n\n**중요**: Node.js를 설치하지 않으면 **다음과 같은 작업을 할 수 없습니다**:\n\n- React, Next.js 같은 프론트엔드 프레임워크 프로젝트 실행 불가\n- `npm install`, `npm start`, `npm run dev` 같은 명령어 사용 불가\n- package.json이 있는 프로젝트 실행 불가\n- Node.js로 작성된 서버 프로그램 실행 불가\n\n**설치 방법**:\n\n1. **공식 웹사이트 방문**: [nodejs.org](https://nodejs.org/)\n\n2. **다운로드**: LTS(Long Term Support) 버전 다운로드 권장 (안정적인 버전)\n\n3. **설치**:\n   - Windows: 다운로드한 설치 파일(.msi) 실행 후 안내에 따라 설치\n   - macOS: 다운로드한 설치 파일(.pkg) 실행 후 안내에 따라 설치\n   - Linux: 터미널에서 `curl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -` 후 `sudo apt-get install -y nodejs` 실행\n\n4. **설치 확인**:\n   - 터미널 또는 명령 프롬프트 열기\n   - `node --version` 입력하여 Node.js 버전 확인\n   - `npm --version` 입력하여 npm(Node Package Manager) 버전 확인\n   - 두 명령어 모두 버전이 표시되면 성공\n\n**참고**: Node.js를 설치하면 npm(Node Package Manager)도 자동으로 함께 설치됩니다. npm은 JavaScript 패키지를 설치하고 관리하는 도구입니다.\n\n---\n\n### 왜 필요한가요?\n\n- **Python**: AI 개발, 데이터 처리, 자동화 스크립트 작성 시 필요\n- **Node.js**: 웹 개발(React, Next.js 등), 서버 개발, npm을 통한 패키지 관리 시 필요\n\n대부분의 현대적인 웹 개발 프로젝트는 Node.js가 필요하며, Python은 AI 관련 작업이나 데이터 분석 시 유용합니다.'
          }
        ]
      },
      {
        id: '1-3',
        title: '커서 AI',
        subSubChapters: [
          {
            id: '1-3-(1)',
            title: '(1) 커서 AI란?',
            content: '**커서(Cursor)**는 AI 기반 코드 에디터로, 개발자가 코드를 더 빠르고 효율적으로 작성할 수 있도록 도와주는 혁신적인 도구입니다.\n\n### 주요 특징\n\n1. **AI 기반 코드 생성**: 자연어로 설명하면 AI가 코드를 자동으로 작성\n\n2. **실시간 코드 제안**: 타이핑하는 동안 AI가 코드를 제안하고 완성\n\n3. **코드 리뷰 및 개선**: 작성한 코드를 분석하고 더 나은 방법을 제안\n\n4. **버그 수정**: 에러를 자동으로 찾아내고 수정 방법 제시\n\n5. **다국어 지원**: Python, JavaScript, TypeScript, Java, C++ 등 다양한 언어 지원\n\n---\n\n### 왜 커서 AI인가?\n\n기존의 코드 에디터는 단순히 텍스트를 편집하는 도구였지만, 커서 AI는 **AI와 함께 코딩하는 경험**을 제공합니다. 마치 시니어 개발자와 페어 프로그래밍을 하는 것처럼, AI가 실시간으로 도움을 주고 코드를 개선해줍니다.\n\n비개발자도 자연어로 "로그인 기능을 만들어줘"라고 요청하면, AI가 필요한 코드를 모두 작성해주고 설명까지 해줍니다.'
          },
          {
            id: '1-3-(2)',
            title: '(2) 설치',
            content: '### 1. 커서 AI 다운로드\n\n1. **공식 웹사이트 방문**: [cursor.com](https://cursor.com/)\n\n2. **다운로드**: 운영체제에 맞는 버전 선택 (Windows, macOS, Linux)\n\n3. **설치**: 다운로드한 파일 실행하여 설치 진행\n\n### 2. 한국어 팩 설치\n\n커서 AI에서 한국어 인터페이스를 사용하려면 한국어 언어 팩을 설치해야 합니다.\n\n**명령어로 설치하는 방법**:\n\n1. **명령 팔레트 열기**: `Ctrl + Shift + P` (Windows/Linux) 또는 `Cmd + Shift + P` (macOS)\n\n2. **언어 설정 검색**: "Configure Display Language" 또는 "언어 구성" 입력\n\n3. **한국어 선택**: 목록에서 "한국어" 또는 "Korean" 선택\n\n4. **확장 프로그램 설치**:\n   - 확장 프로그램 탭 열기: `Ctrl + Shift + X` (또는 `Cmd + Shift + X`)\n   - 검색창에 "Korean Language Pack" 입력\n   - Microsoft의 "Korean Language Pack for Visual Studio Code" 설치\n   - 설치 후 커서 AI 재시작\n\n**또는 명령어로 직접 설치**:\n\n터미널 또는 명령 프롬프트에서 다음 명령어를 실행합니다:\n\ncode --install-extension MS-CEINTL.vscode-language-pack-ko\n\n설치 후 커서 AI를 재시작하면 한국어 인터페이스로 변경됩니다.'
          },
          {
            id: '1-3-(3)',
            title: '(3) 설정',
            content: '### 1. 첫 프로젝트 열기\n\n1. **폴더 열기**: File > Open Folder로 작업할 프로젝트 폴더 선택\n\n2. **새 파일 생성**: 원하는 언어로 새 파일 생성 (예: index.html, app.js)\n\n3. **AI 기능 테스트**: 간단한 코드를 작성하거나 AI에게 요청해보기\n\n### 2. Cursor Docs & Rules의 의미\n\nCursor가 강력한 이유는 단순히 코드를 생성하는 데 그치지 않고, 프로젝트 전체 문맥(맥락)을 이해하며 일관성 있는 결과물을 유지할 수 있다는 점에 있습니다.\n\n이때 중요한 두 가지 기능이 Docs(문서화)와 Rules(규칙)입니다.\n\n### 3. Cursor Docs\n\nCursor Docs는 프로젝트 전반에 대한 중요한 정보가 저장되는 AI 전용 지식 저장소입니다.\n\n- 무엇을 만들고 있는지\n- 어떤 구조로 되어 있는지\n- 페이지, 컴포넌트, 데이터는 어떻게 연결되는지\n\n이와 같은 내용을 정리해두면 Cursor는 코드를 생성하거나 수정할 때 Docs를 자동으로 참고합니다. 즉 사용자가 반복해서 설명하지 않아도, AI가 스스로 문맥을 파악해 더 정확한 결과물을 만들어내는 것입니다.\n\nDocs는 프로젝트가 커질수록 더욱 유용해집니다. 다양한 기능과 파일이 확장되더라도 AI가 전체 구조를 잃지 않기 때문에, 품질을 유지하며 빠르게 기능을 추가할 수 있습니다.\n\n**한 문장 요약**:\n\nDocs는 AI에게 "프로젝트가 어떤 세계인지" 알려주는 지식 기반입니다.\n\n### 4. Cursor Rules\n\n반면 Rules는 프로젝트가 반드시 준수해야 하는 개발 기준과 원칙을 정의합니다.\n\n예를 들어:\n\n- 어떤 언어와 프레임워크를 사용할지\n- 파일 및 컴포넌트의 이름 규칙\n- import 정리 방식\n- 보안이나 스타일 규칙 등\n\nRules가 설정되면 Cursor는 코드 생성 시 이 규칙을 자동 반영하고 위반 시 스스로 수정합니다.\n\n이는 곧 개인과 팀 모두에게 있어 높은 일관성과 유지보수성을 제공합니다.\n\n**한 문장 요약**:\n\nRules는 "이 프로젝트는 이렇게 만들어야 한다"는 AI 개발 가이드라인입니다.\n\n### 5. 유저 룰과 프로젝트 룰\n\nCursor Rules는 두 가지 유형으로 나뉩니다:\n\n**유저 룰 (User Rules)**:\n\n- **위치**: 개인 설정에 저장되는 규칙\n- **적용 범위**: 사용자가 작업하는 모든 프로젝트에 자동으로 적용\n- **용도**: 개인적인 코딩 스타일, 선호하는 패턴, 개인 개발 원칙 등\n- **예시**:\n  - "항상 함수형 컴포넌트를 사용한다"\n  - "주석은 한국어로 작성한다"\n  - "변수명은 camelCase를 사용한다"\n\n**프로젝트 룰 (Project Rules)**:\n\n- **위치**: 프로젝트 루트에 저장되는 규칙 (`.cursorrules` 파일)\n- **적용 범위**: 해당 프로젝트에만 적용\n- **용도**: 프로젝트별 특정 요구사항, 팀 컨벤션, 프로젝트 고유 규칙 등\n- **예시**:\n  - "이 프로젝트는 Next.js 14를 사용한다"\n  - "API 호출은 `/api` 폴더의 함수를 통해서만 한다"\n  - "컴포넌트는 `components/` 폴더에 저장한다"\n\n**차이점과 활용**:\n\n- **유저 룰**: 개인의 일관된 코딩 스타일을 모든 프로젝트에 적용하고 싶을 때 사용\n- **프로젝트 룰**: 특정 프로젝트의 고유한 요구사항이나 팀 규칙을 정의할 때 사용\n- **우선순위**: 프로젝트 룰이 유저 룰보다 우선 적용됩니다. 같은 규칙이 있을 경우 프로젝트 룰이 적용됩니다.\n\n**실전 활용**:\n\n- 개인 프로젝트: 유저 룰만으로도 충분할 수 있습니다.\n- 팀 프로젝트: 프로젝트 룰을 설정하여 모든 팀원이 동일한 규칙을 따르도록 합니다.\n- 여러 프로젝트 작업: 유저 룰로 기본 스타일을 유지하고, 프로젝트 룰로 프로젝트별 특수 요구사항을 추가합니다.'
          },
          {
            id: '1-3-(4)',
            title: '(4) UI 구성 요소 이해하기',
            content: '커서 AI의 인터페이스를 이해하면 더 효율적으로 사용할 수 있습니다.\n\n### 1. 에디터 영역 (Editor Area)\n\n화면 중앙의 큰 영역으로, 코드를 작성하고 편집하는 메인 작업 공간입니다.\n\n- **파일 탐색기**: 왼쪽 사이드바에서 프로젝트의 파일과 폴더를 탐색\n- **탭**: 열려있는 파일들이 상단에 탭으로 표시됨\n- **코드 영역**: 실제 코드를 작성하는 공간\n- **라인 번호**: 각 줄의 왼쪽에 번호가 표시되어 코드 위치를 쉽게 파악\n\n### 2. AI 패널 (AI Panel)\n\n**통합 AI 패널**:\n\nComposer와 Chat이 하나의 통합된 AI 패널로 작동합니다.\n\n- **위치**: 화면 오른쪽 또는 하단에 표시\n- **열기**: `Ctrl + L` (또는 `Cmd + L`) 또는 `Ctrl + I` (또는 `Cmd + I`)\n- **기능**:\n  - **Chat 모드**: AI와 대화하며 코드 작성 요청, 코드 설명, 버그 수정, 질문과 답변\n  - **Composer 모드**: 여러 파일을 동시에 수정, 전체 프로젝트 구조 변경, 복잡한 리팩토링 작업\n  - **모드 전환**: 패널 내에서 Chat과 Composer 모드를 쉽게 전환 가능\n  - **통합 인터페이스**: 하나의 패널에서 대화와 멀티 파일 편집을 모두 수행\n\n### 3. 사이드바 (Sidebar)\n\n**파일 탐색기**:\n\n- **위치**: 왼쪽 사이드바\n- **열기/닫기**: `Ctrl + B` (또는 `Cmd + B`)\n- **기능**:\n  - 프로젝트 파일 구조 확인\n  - 파일 생성, 삭제, 이름 변경\n  - 폴더 탐색\n\n**확장 프로그램**:\n\n- **위치**: 왼쪽 사이드바\n- **열기**: `Ctrl + Shift + X` (또는 `Cmd + Shift + X`)\n- **기능**:\n  - 확장 프로그램 검색 및 설치\n  - 설치된 확장 프로그램 관리\n\n**검색**:\n\n- **위치**: 왼쪽 사이드바\n- **열기**: `Ctrl + Shift + F` (또는 `Cmd + Shift + F`)\n- **기능**:\n  - 프로젝트 전체에서 텍스트 검색\n  - 파일 내 검색 및 바꾸기\n\n### 4. 상태바 (Status Bar)\n\n화면 하단에 표시되는 정보 바입니다.\n\n- **브랜치 정보**: Git 브랜치 이름 표시\n- **에러/경고 개수**: 파일의 에러와 경고 개수\n- **언어 모드**: 현재 파일의 프로그래밍 언어\n- **줄/열 번호**: 커서의 현재 위치\n\n### 5. 명령 팔레트 (Command Palette)\n\n모든 명령을 빠르게 실행할 수 있는 검색 창입니다.\n\n- **열기**: `Ctrl + Shift + P` (또는 `Cmd + Shift + P`)\n- **기능**:\n  - 모든 기능을 키보드로 빠르게 접근\n  - 명령어 검색으로 원하는 기능 실행\n  - 설정 변경\n  - 확장 프로그램 관리\n\n### 6. 인라인 AI 제안 (Inline AI Suggestions)\n\n코드를 타이핑할 때 자동으로 나타나는 AI 제안입니다.\n\n- **위치**: 코드 입력 중 자동으로 표시\n- **수락**: `Tab` 키로 제안 수락\n- **거부**: `Esc` 키로 제안 거부\n- **부분 수락**: `Ctrl + →` (또는 `Cmd + →`)로 일부만 수락\n\n### 7. 터미널 (Terminal)\n\n명령어를 실행할 수 있는 터미널 창입니다.\n\n- **위치**: 하단 패널\n- **열기**: `Ctrl + `` (백틱) 또는 `Ctrl + Shift + ``\n- **기능**:\n  - npm, git 등 명령어 실행\n  - 프로젝트 빌드 및 실행\n  - 로그 확인\n\n---\n\n### UI 레이아웃 팁\n\n- **패널 크기 조절**: 패널 사이의 경계선을 드래그하여 크기 조절\n- **패널 숨기기/보이기**: 각 패널의 아이콘을 클릭하여 토글\n- **전체 화면 모드**: `F11`로 전체 화면 모드 전환\n- **줄 번호 표시/숨기기**: 설정에서 조절 가능'
          },
          {
            id: '1-3-(5)',
            title: '(5) 주요 기능',
            content: '### 1. 통합 AI 패널 (Chat & Composer)\n\n**Ctrl + L** (또는 Cmd + L) 또는 **Ctrl + I** (또는 Cmd + I)를 누르면 통합된 AI 패널이 열립니다.\n\n**Chat 모드**:\n\n- AI와 대화하며 코드 작성 요청: "로그인 폼을 만들어줘"\n- 코드 설명 요청: "이 코드가 뭘 하는지 설명해줘"\n- 버그 수정 요청: "이 에러를 고쳐줘"\n- 코드 개선 요청: "이 코드를 더 효율적으로 바꿔줘"\n- 질문과 답변\n\n**Composer 모드**:\n\n- 여러 파일을 동시에 수정\n- 전체 프로젝트 구조 변경\n- 여러 파일에 걸친 리팩토링\n- 새로운 기능 추가\n- 복잡한 작업을 한 번에 처리\n\n**모드 전환**:\n\n- 패널 내에서 Chat과 Composer 모드를 쉽게 전환\n- 작업 유형에 따라 적절한 모드 선택\n- 하나의 패널에서 모든 AI 기능 활용\n\n### 3. Tab 자동완성\n\n코드를 타이핑하면 AI가 자동으로 다음 코드를 제안합니다.\n\n- **Tab 키**: 제안된 코드 수락\n- **Esc 키**: 제안 거부\n- **Ctrl + →**: 제안의 일부만 수락\n\n### 4. 인라인 편집\n\n코드 블록을 선택하고 **Ctrl + K**를 누르면 해당 부분만 수정할 수 있습니다.\n\n- 특정 함수만 개선\n- 변수명 변경\n- 주석 추가\n\n### 5. 코드 리뷰\n\n전체 파일이나 선택한 코드를 AI에게 리뷰 요청할 수 있습니다.\n\n- 보안 취약점 검사\n- 성능 최적화 제안\n- 코드 스타일 개선\n\n---\n\n### 6. 파일 생성 및 수정\n\nAI에게 "새로운 컴포넌트를 만들어줘"라고 요청하면, 파일을 자동으로 생성하고 필요한 코드를 모두 작성해줍니다.'
          },
          {
            id: '1-3-(6)',
            title: '(6) 프롬프트 작성 팁',
            content: '### 1. 구체적으로 요청하기\n\n❌ 나쁜 예: "웹사이트 만들어줘"\n\n✅ 좋은 예: "반응형 랜딩 페이지를 만들어줘. 헤더에는 로고와 네비게이션 메뉴, 메인 섹션에는 제목과 CTA 버튼, 푸터에는 연락처 정보를 넣어줘. Tailwind CSS를 사용하고 모던한 디자인으로 만들어줘."\n\n### 2. 맥락 제공하기\n\n- 사용하는 프레임워크나 라이브러리 명시\n- 기존 코드 스타일 유지 요청\n- 특정 요구사항이나 제약사항 언급\n\n### 3. 단계별로 요청하기\n\n복잡한 기능은 여러 단계로 나눠서 요청하는 것이 좋습니다.\n\n1. "사용자 인증 기능의 기본 구조를 만들어줘"\n2. "로그인 폼 UI를 추가해줘"\n3. "비밀번호 재설정 기능을 추가해줘"\n\n### 4. 예시 제공하기\n\n원하는 결과물의 예시나 참고할 코드를 제공하면 더 정확한 결과를 얻을 수 있습니다.\n\n"이 코드를 참고해서 비슷한 스타일로 만들어줘"\n\n### 5. 피드백 주고받기\n\nAI가 작성한 코드가 마음에 들지 않으면:\n\n- "이 부분을 더 간단하게 바꿔줘"\n- "성능을 개선해줘"\n- "다른 방법으로 다시 작성해줘"\n\n---\n\n### 6. 에러 메시지 활용하기\n\n에러가 발생하면 에러 메시지를 그대로 AI에게 보여주면 해결 방법을 제시해줍니다.'
          },
          {
            id: '1-3-(7)',
            title: '(7) 실전 활용 예제',
            content: '### 예제 1: 간단한 할 일 목록 만들기\n\n**프롬프트**:\n\n"React를 사용해서 할 일 목록 앱을 만들어줘. 추가, 삭제, 완료 체크 기능이 있어야 해."\n\n**결과**:\n\n- TodoList 컴포넌트 자동 생성\n- 상태 관리 코드 작성\n- UI 스타일링 완료\n\n### 예제 2: 버그 수정\n\n**에러 메시지**:\n\n"TypeError: Cannot read property \'map\' of undefined"\n\n**프롬프트**:\n\n"이 에러를 고쳐줘. users 배열이 undefined일 수 있어."\n\n**결과**:\n\n- 옵셔널 체이닝(?.) 추가\n- 기본값 설정\n- 방어 코드 작성\n\n### 예제 3: 코드 리팩토링\n\n**프롬프트**:\n\n"이 코드를 더 깔끔하게 리팩토링해줘. 함수를 작은 단위로 나누고, 변수명을 더 명확하게 바꿔줘."\n\n**결과**:\n\n- 함수 분리\n- 의미 있는 변수명으로 변경\n- 주석 추가\n- 코드 구조 개선\n\n---\n\n### 예제 4: 테스트 코드 작성\n\n**프롬프트**:\n\n"이 함수에 대한 Jest 테스트 코드를 작성해줘. 모든 엣지 케이스를 포함해줘."\n\n**결과**:\n\n- 테스트 파일 생성\n- 다양한 케이스 테스트 작성\n- Mock 데이터 설정'
          },
          {
            id: '1-3-(8)',
            title: '(8) 고급 기능 및 팁',
            content: '### 1. 컨텍스트 활용\n\nAI에게 더 정확한 답변을 받으려면:\n\n- 관련 파일들을 함께 선택\n- 프로젝트 구조 설명\n- 사용 중인 라이브러리 정보 제공\n\n### 2. 코드베이스 학습\n\n커서 AI는 열려있는 파일들을 학습해서 프로젝트의 스타일과 패턴을 이해합니다.\n\n- 여러 파일을 열어두면 더 일관된 코드 생성\n- 기존 코드 스타일을 따라 작성\n\n### 3. 단축키 활용\n\n- **Ctrl + K**: 인라인 편집 (코드 선택 후)\n- **Ctrl + L** 또는 **Ctrl + I**: 통합 AI 패널 열기 (Chat & Composer)\n- **Tab**: AI 제안 수락\n- **Esc**: AI 제안 거부\n- **Ctrl + Shift + P**: 명령 팔레트 열기\n\n### 4. 멀티 파일 편집\n\n통합 AI 패널의 Composer 모드를 사용하면 여러 파일을 동시에 수정할 수 있습니다.\n\n"로그인 기능을 추가해줘. auth.js 파일에 함수를 만들고, login.jsx 파일에 UI를 추가해줘."\n\n통합된 인터페이스로 Chat과 Composer 기능을 하나의 패널에서 모두 사용할 수 있어 더욱 편리합니다.\n\n### 5. 코드 검색 및 분석\n\n**Ctrl + Shift + F**로 코드베이스 전체를 검색하고, AI에게 "이 함수가 어디서 사용되는지 찾아줘"라고 요청할 수 있습니다.\n\n---\n\n### 6. 성능 최적화\n\n- 큰 파일은 여러 작은 파일로 분리\n- 불필요한 AI 제안은 Esc로 거부하여 리소스 절약\n- 특정 파일만 열어서 컨텍스트 제한'
          },
          {
            id: '1-3-(9)',
            title: '(9) AI 모드',
            content: '커서 AI는 다양한 AI 모드를 제공하여 사용자의 필요에 맞는 기능을 선택할 수 있습니다.\n\n### 1. 에이전트 (Agent)\n\n에이전트는 AI가 자율적으로 복잡한 작업을 수행하는 모드입니다.\n\n**주요 특징**:\n\n- **자율 작업 수행**: AI가 복잡한 작업을 단계별로 계획하고 자동으로 실행\n- **멀티 스텝 작업**: 여러 파일을 순차적으로 수정하고 테스트까지 수행\n- **컨텍스트 이해**: 프로젝트 전체 구조를 이해하고 일관된 코드 작성\n- **자동 리팩토링**: 코드베이스 전체를 분석하여 개선 사항 제안 및 적용\n- **지능형 작업 분해**: 큰 작업을 작은 단계로 나누어 체계적으로 처리\n\n**사용 예시**:\n\n"사용자 인증 시스템을 만들어줘. 로그인, 회원가입, 비밀번호 재설정 기능을 포함하고, 모든 파일을 생성하고 테스트까지 해줘."\n\n에이전트가 자동으로:\n1. 필요한 파일 구조 생성\n2. 각 기능별 코드 작성\n3. 파일 간 연결\n4. 기본 테스트 코드 작성\n\n**활용 시나리오**:\n\n- 복잡한 기능 개발\n- 여러 파일에 걸친 리팩토링\n- 프로젝트 구조 개선\n- 자동화된 테스트 작성\n\n### 2. 플랜 (Plan)\n\n플랜 모드는 AI가 작업 계획을 세우고 단계별로 실행 계획을 제시하는 모드입니다.\n\n**주요 특징**:\n\n- **작업 계획 수립**: AI가 요청된 작업을 분석하여 실행 계획을 세움\n- **단계별 제시**: 작업을 단계별로 나누어 순서대로 제시\n- **사전 검토**: 실행 전에 계획을 검토하고 수정 가능\n- **체계적 접근**: 복잡한 작업을 체계적으로 처리할 수 있도록 도움\n\n**사용 방법**:\n\n1. AI 패널에서 플랜 모드 선택\n2. 작업 요청 (예: "로그인 기능을 추가해줘")\n3. AI가 작업 계획을 단계별로 제시\n4. 계획을 검토하고 승인하면 실행\n\n**활용 시나리오**:\n\n- 대규모 기능 개발 전 계획 수립\n- 복잡한 리팩토링 작업 계획\n- 프로젝트 구조 변경 계획\n- 작업 순서가 중요한 경우\n\n### 3. 애스크 (Ask)\n\n애스크 모드는 AI에게 질문하고 답변을 받는 대화형 모드입니다.\n\n**주요 특징**:\n\n- **질문과 답변**: AI에게 코드나 개념에 대해 질문하고 답변 받기\n- **코드 설명**: 작성된 코드의 동작 원리와 목적 설명 요청\n- **문제 해결**: 에러나 버그에 대한 해결 방법 문의\n- **학습 도구**: 코딩 개념과 베스트 프랙티스 학습\n- **대화형 인터페이스**: 자연스러운 대화로 정보 교환\n\n**사용 방법**:\n\n1. AI 패널에서 애스크 모드 선택\n2. 질문 입력 (예: "이 코드가 뭘 하는지 설명해줘")\n3. AI가 상세한 답변 제공\n4. 추가 질문으로 더 깊이 있는 설명 요청 가능\n\n**활용 시나리오**:\n\n- 코드 이해가 필요한 경우\n- 에러 메시지 해석\n- 프로그래밍 개념 학습\n- 베스트 프랙티스 문의\n- 코드 리뷰 및 개선 방법 문의\n\n**사용 예시**:\n\n- "이 함수가 어떻게 동작하는지 설명해줘"\n- "이 에러를 어떻게 고칠 수 있어?"\n- "React Hooks를 언제 사용해야 해?"\n- "이 코드를 더 효율적으로 만들 수 있어?"'
          },
          {
            id: '1-3-(10)',
            title: '(10) AI 모델',
            content: '커서 AI에서는 AI 모델을 선택할 때 두 가지 옵션을 제공합니다.\n\n### 1. Auto (자동)\n\nAI가 작업 유형에 따라 자동으로 최적의 모델을 선택합니다.\n\n**주요 특징**:\n\n- **자동 모델 선택**: AI가 작업 유형에 따라 최적의 모델을 자동으로 선택\n- **효율적인 리소스 사용**: 필요한 만큼만 리소스를 사용하여 비용 효율적\n- **편리함**: 사용자가 모델을 신경 쓸 필요 없이 자동으로 최적화\n- **일반 작업에 적합**: 대부분의 일반적인 코딩 작업에 충분한 성능\n\n**사용 시나리오**:\n\n- 일반적인 코드 작성\n- 간단한 수정 작업\n- 일상적인 개발 작업\n- 리소스 효율성이 중요한 경우\n\n### 2. Max (최대)\n\n항상 최고 성능의 모델을 사용합니다.\n\n**주요 특징**:\n\n- **최고 성능**: 가장 강력한 AI 모델로 작업 수행\n- **높은 정확도**: 복잡한 작업에서도 높은 정확도와 품질 보장\n- **복잡한 작업 적합**: 복잡하고 중요한 작업에 최적화\n- **최상의 결과**: 최고 품질의 코드 생성과 문제 해결\n\n**사용 시나리오**:\n\n- 복잡한 리팩토링 작업\n- 중요한 기능 개발\n- 정확도가 매우 중요한 경우\n- 대규모 프로젝트 작업\n- 아키텍처 설계 및 개선\n\n---\n\n### 3. 선택 팁\n\n**Auto를 선택하는 경우**:\n\n- 일반적인 코딩 작업\n- 간단한 버그 수정\n- 일상적인 개발 업무\n- 비용 효율성을 고려하는 경우\n\n**Max를 선택하는 경우**:\n\n- 복잡한 로직 구현\n- 대규모 리팩토링\n- 중요한 기능 개발\n- 최고 품질이 필요한 경우\n- 프로젝트의 핵심 부분 작업\n\n### 3. Thinking 모드\n\nThinking 모드는 AI가 사고 과정을 보여주는 모드입니다.\n\n**주요 특징**:\n\n- **사고 과정 공개**: AI가 문제를 어떻게 분석하고 해결하는지 단계별로 표시\n- **추론 과정 확인**: AI의 논리적 사고 과정을 실시간으로 확인 가능\n- **이해도 향상**: AI의 판단 근거를 이해하여 더 나은 결과물 기대\n- **학습 도구**: AI의 사고 방식을 학습하여 자신의 코딩 스타일 개선\n\n**사용 시나리오**:\n\n- 복잡한 문제 해결이 필요한 경우\n- AI의 추론 과정을 이해하고 싶을 때\n- 코드 리뷰와 개선 과정을 자세히 보고 싶을 때\n- AI의 사고 방식을 학습하고 싶을 때\n\n**활용 방법**:\n\n- AI 패널에서 Thinking 모드 활성화\n- 질문이나 요청을 하면 AI가 단계별로 사고 과정을 보여줌\n- 각 단계의 추론을 확인하며 진행 상황 파악\n\n---\n\n### 4. 모델 활용 팁\n\n- **일반 작업**: Auto 모드로 충분\n- **복잡한 기능 개발**: Max 모드 활성화\n- **사고 과정 확인**: Thinking 모드로 AI의 추론 과정 확인\n- **대규모 리팩토링**: Max 모드 + 에이전트 플랜\n- **자동화 작업**: 에이전트 플랜으로 멀티 스텝 작업 수행\n- **학습 목적**: Thinking 모드로 AI의 사고 방식을 학습'
          },
          {
            id: '1-3-(11)',
            title: '(11) Git 커밋과 푸시',
            content: 'Git은 코드의 버전을 관리하는 도구이며, 커밋과 푸시는 변경사항을 저장하고 공유하는 핵심 작업입니다.\n\n### 1. 커밋 (Commit)이란?\n\n커밋은 현재 작업한 변경사항을 Git 저장소에 영구적으로 저장하는 작업입니다.\n\n**커밋의 의미**:\n\n- **스냅샷 저장**: 현재 프로젝트 상태를 하나의 스냅샷으로 저장\n- **변경 이력 기록**: 언제, 무엇을, 왜 변경했는지 기록\n- **되돌리기 가능**: 나중에 특정 커밋으로 되돌릴 수 있음\n- **작업 단위 구분**: 논리적으로 관련된 변경사항을 하나의 커밋으로 묶음\n\n**커밋 메시지 작성 팁**:\n\n- 명확하고 간결하게 작성\n- 무엇을 변경했는지 설명\n- 왜 변경했는지 간단히 언급 (필요한 경우)\n- 예시: "로그인 기능 추가", "버그 수정: 사용자 인증 오류 해결"\n\n### 2. 푸시 (Push)란?\n\n푸시는 로컬 저장소의 커밋을 원격 저장소(GitHub, GitLab 등)에 업로드하는 작업입니다.\n\n**푸시의 의미**:\n\n- **원격 저장소 업데이트**: 로컬에서 만든 커밋을 원격 저장소에 반영\n- **협업 가능**: 팀원들이 최신 변경사항을 받을 수 있게 함\n- **백업**: 코드를 원격 저장소에 백업\n- **배포 준비**: 원격 저장소의 코드를 서버에 배포할 수 있음\n\n**푸시 전 확인사항**:\n\n- 커밋이 완료되었는지 확인\n- 원격 저장소 주소가 올바른지 확인\n- 권한이 있는지 확인 (원격 저장소에 쓰기 권한 필요)\n\n### 3. 기본 Git 명령어\n\n**커밋하기**:\n\n1. **변경사항 확인**: `git status`\n   - 어떤 파일이 변경되었는지 확인\n\n2. **스테이징**: `git add <파일명>` 또는 `git add .`\n   - 변경된 파일을 스테이징 영역에 추가\n   - `git add .`는 모든 변경사항을 추가\n\n3. **커밋 생성**: `git commit -m "커밋 메시지"`\n   - 스테이징된 변경사항을 커밋으로 저장\n\n**푸시하기**:\n\n1. **원격 저장소 확인**: `git remote -v`\n   - 연결된 원격 저장소 주소 확인\n\n2. **푸시 실행**: `git push`\n   - 로컬 커밋을 원격 저장소에 업로드\n   - `git push origin main` (또는 브랜치 이름)\n\n### 4. 실전 워크플로우\n\n**일반적인 작업 흐름**:\n\n1. 코드 수정\n2. `git status`로 변경사항 확인\n3. `git add .`로 모든 변경사항 스테이징\n4. `git commit -m "변경 내용 설명"`로 커밋\n5. `git push`로 원격 저장소에 푸시\n\n**예시**:\n\ngit status                    # 변경사항 확인\ngit add .                     # 모든 파일 스테이징\ngit commit -m "로그인 기능 추가"  # 커밋 생성\ngit push                      # 원격 저장소에 푸시\n\n### 5. 주의사항\n\n**커밋 전**:\n\n- 변경사항을 확인하고 테스트\n- 불필요한 파일은 `.gitignore`에 추가\n- 커밋 메시지는 명확하게 작성\n\n**푸시 전**:\n\n- 다른 사람이 먼저 푸시했는지 확인 (`git pull`)\n- 충돌이 없는지 확인\n- 중요한 정보(비밀번호, API 키 등)가 포함되지 않았는지 확인\n\n### 6. 유용한 팁\n\n- **작은 단위로 커밋**: 관련된 변경사항만 하나의 커밋으로 묶기\n- **자주 커밋하기**: 작업이 완료될 때마다 커밋하여 이력을 명확하게 유지\n- **의미 있는 커밋 메시지**: 나중에 이력을 볼 때 이해하기 쉽도록 작성\n- **푸시 전 확인**: `git log`로 커밋 이력 확인 후 푸시'
          }
        ]
      },
      {
        id: '1-4',
        title: '백엔드',
        subSubChapters: [
          {
            id: '1-4-(1)',
            title: '(1) 파이어베이스',
            content: '### Firebase란?\n\nFirebase는 구글이 제공하는 백엔드 서비스 플랫폼입니다. 서버 구축 없이도 데이터베이스, 인증, 스토리지, 호스팅 등 다양한 백엔드 기능을 사용할 수 있습니다.\n\n**Firebase의 주요 기능**:\n\n- **실시간 데이터베이스**: 실시간으로 데이터 동기화\n- **인증 (Authentication)**: 이메일, 소셜 로그인 등 사용자 인증\n- **클라우드 스토리지**: 파일 업로드 및 저장\n- **호스팅**: 정적 웹사이트 호스팅\n- **클라우드 함수**: 서버리스 함수 실행\n- **푸시 알림**: 모바일 앱 푸시 알림\n- **분석**: 사용자 행동 분석\n\n### Firebase 계정 만들기\n\n1. **웹사이트 방문**: [firebase.google.com](https://firebase.google.com/)\n\n2. **회원가입**:\n   - "Get started" 또는 "시작하기" 버튼 클릭\n   - Google 계정으로 로그인\n   - Firebase Console 접속\n\n3. **프로젝트 생성**:\n   - "프로젝트 추가" 또는 "Add project" 클릭\n   - 프로젝트 이름 입력\n   - Google Analytics 설정 (선택사항)\n   - 프로젝트 생성 완료\n\n### Firebase 프로젝트 설정\n\n1. **프로젝트 선택**:\n   - Firebase Console에서 생성한 프로젝트 선택\n   - 프로젝트 대시보드로 이동\n\n2. **웹 앱 추가**:\n   - 프로젝트 개요 페이지에서 웹 아이콘 클릭\n   - 앱 닉네임 입력\n   - Firebase SDK 설정 코드 확인 (나중에 사용)\n   - "앱 등록" 클릭\n\n3. **설정 정보 확인**:\n   - Firebase 설정 객체 확인\n   - apiKey, authDomain, projectId 등 정보 복사\n   - 이 정보는 프로젝트 코드에 사용됨\n\n### Firebase 주요 서비스 사용하기\n\n**1. Authentication (인증)**:\n\n- 사용자 로그인, 회원가입 기능 제공\n- 이메일/비밀번호, Google, Facebook 등 소셜 로그인 지원\n- 사용자 세션 관리 자동 처리\n\n**2. Firestore (데이터베이스)**:\n\n- NoSQL 데이터베이스\n- 실시간 데이터 동기화\n- 쿼리 및 인덱싱 지원\n- 자동 확장 가능\n\n**3. Storage (스토리지)**:\n\n- 파일 업로드 및 다운로드\n- 이미지, 동영상 등 미디어 파일 저장\n- 보안 규칙으로 접근 제어\n\n**4. Hosting (호스팅)**:\n\n- 정적 웹사이트 호스팅\n- CDN을 통한 빠른 전송\n- HTTPS 자동 설정\n- 커스텀 도메인 연결 가능\n\n### Firebase 요금제\n\n**Spark (무료)**:\n\n- **인증**: 월 50,000명 무료\n- **Firestore**: 저장 1GB, 읽기/쓰기 제한\n- **Storage**: 저장 5GB, 다운로드 1GB/일\n- **Hosting**: 저장 10GB, 전송 360MB/일\n- **Cloud Functions**: 월 125,000회 호출\n- 개인 프로젝트 및 소규모 앱에 적합\n\n**Blaze (종량제)**:\n\n- **무료 할당량**: Spark 플랜의 무료 할당량 포함\n- **초과분 과금**: 사용량에 따라 과금\n- **확장성**: 무제한 사용 가능\n- 프로덕션 앱에 적합\n\n**개인 사용자 권장**:\n\n- 대부분의 개인 프로젝트는 **Spark 플랜(무료)**으로 충분합니다\n- 무료 할당량으로 충분한 기능 사용 가능\n- 프로젝트가 성장하면 Blaze 플랜으로 자동 전환 (무료 할당량은 계속 무료)\n\n### Firebase의 장점\n\n- **서버 구축 불필요**: 백엔드 서버를 직접 구축할 필요 없음\n- **빠른 개발**: 몇 분 내 백엔드 기능 구현 가능\n- **실시간 동기화**: 데이터 변경사항 실시간 반영\n- **확장성**: 자동으로 트래픽에 맞춰 확장\n- **Google 인프라**: 구글의 안정적인 인프라 활용\n- **무료 시작**: 무료 플랜으로 충분히 시작 가능'
          },
          {
            id: '1-4-(2)',
            title: '(2) 수파베이스',
            content: '### Supabase란?\n\nSupabase는 오픈소스 Firebase 대안으로, PostgreSQL 데이터베이스를 기반으로 한 백엔드 서비스 플랫폼입니다. SQL을 사용할 수 있어 기존 데이터베이스 지식을 활용하기 쉽습니다.\n\n**Supabase의 주요 기능**:\n\n- **PostgreSQL 데이터베이스**: 강력한 관계형 데이터베이스\n- **인증 (Authentication)**: 사용자 인증 및 권한 관리\n- **실시간 구독**: 데이터베이스 변경사항 실시간 구독\n- **스토리지**: 파일 저장 및 관리\n- **Edge Functions**: 서버리스 함수 실행\n- **API 자동 생성**: RESTful API 자동 생성\n- **대시보드**: 웹 기반 관리 대시보드\n\n### Supabase 계정 만들기\n\n1. **웹사이트 방문**: [supabase.com](https://supabase.com/)\n\n2. **회원가입**:\n   - "Start your project" 또는 "시작하기" 버튼 클릭\n   - GitHub 계정으로 로그인 권장\n   - 또는 이메일로 가입\n\n3. **프로젝트 생성**:\n   - "New Project" 클릭\n   - Organization 선택 또는 생성\n   - 프로젝트 이름 입력\n   - 데이터베이스 비밀번호 설정 (안전하게 보관)\n   - 리전 선택 (가장 가까운 지역 선택)\n   - "Create new project" 클릭\n   - 프로젝트 생성 완료까지 몇 분 소요\n\n### Supabase 프로젝트 설정\n\n1. **프로젝트 대시보드 접속**:\n   - 생성한 프로젝트 선택\n   - 프로젝트 대시보드로 이동\n\n2. **API 키 확인**:\n   - 왼쪽 사이드바에서 "Settings" > "API" 선택\n   - Project URL 확인\n   - anon public key와 service_role key 확인\n   - 이 키들은 프로젝트 코드에 사용됨\n\n3. **데이터베이스 접속 정보**:\n   - Settings > Database에서 연결 정보 확인\n   - Host, Database name, Port, User, Password 확인\n   - 필요시 직접 PostgreSQL에 연결 가능\n\n### Supabase 주요 서비스 사용하기\n\n**1. Database (데이터베이스)**:\n\n### SQL과 관계형 데이터베이스란?\n\n**SQL (Structured Query Language)**:\n\nSQL은 데이터베이스와 대화하기 위한 표준 언어입니다. 데이터를 저장, 조회, 수정, 삭제하는 명령어를 제공합니다.\n\n**주요 SQL 명령어**:\n\n- **SELECT**: 데이터 조회\n  - 예시: `SELECT * FROM users WHERE age > 18`\n  - users 테이블에서 나이가 18세 이상인 모든 데이터 조회\n\n- **INSERT**: 데이터 추가\n  - 예시: INSERT INTO users (name, email) VALUES (홍길동, hong@example.com)\n  - users 테이블에 새 사용자 추가\n\n- **UPDATE**: 데이터 수정\n  - 예시: UPDATE users SET name = 김철수 WHERE id = 1\n  - id가 1인 사용자의 이름을 김철수로 변경\n\n- **DELETE**: 데이터 삭제\n  - 예시: `DELETE FROM users WHERE id = 1`\n  - id가 1인 사용자 삭제\n\n**관계형 데이터베이스 (Relational Database)**:\n\n관계형 데이터베이스는 데이터를 테이블(표) 형태로 저장하고, 테이블 간의 관계를 정의하여 데이터를 관리하는 방식입니다.\n\n**주요 개념**:\n\n1. **테이블 (Table)**:\n   - 데이터를 행(row)과 열(column)로 구성된 표 형태로 저장\n   - 예시: users 테이블, products 테이블, orders 테이블\n\n2. **행 (Row)**:\n   - 하나의 레코드, 하나의 데이터 항목\n   - 예시: 한 명의 사용자 정보\n\n3. **열 (Column)**:\n   - 데이터의 속성, 필드\n   - 예시: name, email, age 등\n\n4. **기본 키 (Primary Key)**:\n   - 각 행을 고유하게 식별하는 열\n   - 예시: id (1, 2, 3...)\n\n5. **외래 키 (Foreign Key)**:\n   - 다른 테이블의 기본 키를 참조하는 열\n   - 테이블 간의 관계를 정의\n   - 예시: orders 테이블의 user_id가 users 테이블의 id를 참조\n\n**관계형 데이터베이스의 관계 유형**:\n\n1. **일대일 (One-to-One)**:\n   - 한 테이블의 한 행이 다른 테이블의 한 행과 연결\n   - 예시: 사용자와 사용자 프로필\n\n2. **일대다 (One-to-Many)**:\n   - 한 테이블의 한 행이 다른 테이블의 여러 행과 연결\n   - 예시: 한 사용자가 여러 주문을 가짐\n\n3. **다대다 (Many-to-Many)**:\n   - 한 테이블의 여러 행이 다른 테이블의 여러 행과 연결\n   - 중간 테이블(조인 테이블) 필요\n   - 예시: 학생과 수업 (한 학생이 여러 수업을 듣고, 한 수업에 여러 학생이 등록)\n\n**Supabase의 데이터베이스 기능**:\n\n- **PostgreSQL 기반**: 업계 표준 관계형 데이터베이스\n- **Table Editor**: 웹 대시보드에서 테이블 생성 및 데이터 관리\n- **SQL Editor**: 직접 SQL 쿼리 작성 및 실행\n- **외래 키**: 테이블 간 관계 설정\n- **제약 조건**: 데이터 무결성 보장 (NOT NULL, UNIQUE, CHECK 등)\n- **인덱스**: 빠른 데이터 조회를 위한 인덱스 생성\n- **트리거**: 데이터 변경 시 자동 실행되는 함수\n- **뷰 (View)**: 복잡한 쿼리를 간단하게 사용\n\n### 관계형 데이터베이스의 장점\n\n**1. 데이터 무결성**:\n\n- **제약 조건**: 잘못된 데이터 입력 방지\n- **외래 키**: 참조 무결성 보장 (존재하지 않는 데이터 참조 불가)\n- **트랜잭션**: 여러 작업을 하나의 단위로 처리 (모두 성공하거나 모두 실패)\n\n**2. 데이터 중복 최소화**:\n\n- **정규화**: 데이터를 논리적으로 분리하여 중복 제거\n- **효율적인 저장**: 같은 데이터를 여러 곳에 저장하지 않음\n- **일관성**: 한 곳에서 수정하면 모든 곳에 반영\n\n**3. 복잡한 쿼리 지원**:\n\n- **JOIN**: 여러 테이블을 연결하여 복잡한 데이터 조회\n- **집계 함수**: COUNT, SUM, AVG 등으로 데이터 분석\n- **서브쿼리**: 쿼리 안에 쿼리 작성 가능\n\n**4. 표준화된 언어**:\n\n- **SQL 표준**: 모든 관계형 데이터베이스에서 사용 가능\n- **이식성**: 다른 데이터베이스로 쉽게 이전 가능\n- **학습 자료**: 풍부한 학습 자료와 커뮤니티\n\n**5. 강력한 기능**:\n\n- **트랜잭션**: ACID 속성 보장 (원자성, 일관성, 격리성, 지속성)\n- **동시성 제어**: 여러 사용자가 동시에 접근해도 안전\n- **백업 및 복구**: 데이터 손실 방지 및 복구 가능\n\n### 관계형 데이터베이스의 단점\n\n**1. 복잡한 구조**:\n\n- **설계 어려움**: 초보자에게는 테이블 설계가 어려울 수 있음\n- **정규화 학습**: 효율적인 데이터 구조를 만들기 위해 학습 필요\n- **관계 이해**: 테이블 간 관계를 이해하고 설계해야 함\n\n**2. 확장성 제한**:\n\n- **수평 확장 어려움**: 여러 서버에 분산하기 어려움\n- **수직 확장**: 더 강력한 서버가 필요 (비용 증가)\n- **대규모 트래픽**: 매우 큰 규모에서는 성능 이슈 가능\n\n**3. 유연성 부족**:\n\n- **스키마 고정**: 테이블 구조 변경이 어려울 수 있음\n- **구조 변경**: 이미 많은 데이터가 있으면 구조 변경이 복잡\n- **계층적 데이터**: 트리 구조 데이터 표현이 복잡\n\n**4. 성능 이슈**:\n\n- **JOIN 연산**: 복잡한 JOIN은 성능 저하 가능\n- **인덱스 관리**: 적절한 인덱스 설계 필요\n- **쿼리 최적화**: 효율적인 쿼리 작성 필요\n\n### SQL vs NoSQL 비교\n\n**SQL (관계형 데이터베이스)**:\n\n- **구조화된 데이터**: 명확한 스키마와 구조\n- **ACID 보장**: 데이터 일관성 보장\n- **복잡한 쿼리**: JOIN, 집계 함수 등 강력한 쿼리\n- **수직 확장**: 더 강력한 서버 필요\n- **예시**: PostgreSQL, MySQL, SQL Server\n\n**NoSQL (비관계형 데이터베이스)**:\n\n- **유연한 구조**: 스키마 없이 데이터 저장 가능\n- **수평 확장**: 여러 서버에 쉽게 분산\n- **빠른 읽기/쓰기**: 단순한 구조로 빠른 성능\n- **대규모 데이터**: 빅데이터 처리에 유리\n- **예시**: MongoDB, Firebase Firestore, DynamoDB\n\n**선택 가이드**:\n\n- **SQL 선택**: 구조화된 데이터, 복잡한 관계, 데이터 일관성이 중요할 때\n- **NoSQL 선택**: 빠른 개발, 대규모 확장, 유연한 구조가 필요할 때\n\n**Supabase의 장점 (SQL 기반)**:\n\n- **기존 지식 활용**: SQL을 알고 있으면 바로 사용 가능\n- **강력한 쿼리**: 복잡한 데이터 조회 및 분석 가능\n- **데이터 무결성**: 제약 조건으로 데이터 품질 보장\n- **표준 준수**: PostgreSQL 표준으로 이식성 높음\n- **오픈소스**: 자체 호스팅 가능하여 벤더 종속성 없음\n\n**2. Authentication (인증)**:\n\n- 이메일/비밀번호 인증\n- 소셜 로그인 (Google, GitHub, Apple 등)\n- Magic Link (비밀번호 없는 로그인)\n- 사용자 관리 및 권한 설정\n\n**3. Storage (스토리지)**:\n\n- 파일 업로드 및 다운로드\n- 버킷(Bucket) 단위로 파일 관리\n- 공개/비공개 파일 설정\n- 이미지 리사이징 자동 지원\n\n**4. Edge Functions**:\n\n- 서버리스 함수 실행\n- TypeScript/JavaScript로 작성\n- API 엔드포인트로 사용 가능\n\n**5. Realtime (실시간)**:\n\n- 데이터베이스 변경사항 실시간 구독\n- WebSocket을 통한 실시간 통신\n- 채팅, 알림 등 실시간 기능 구현\n\n### Supabase 요금제\n\n**Free (무료)**:\n\n- **데이터베이스**: 500MB 저장, 2GB 대역폭\n- **인증**: 무제한 사용자\n- **Storage**: 1GB 저장, 2GB 전송\n- **Edge Functions**: 월 500,000회 호출\n- **프로젝트**: 2개 프로젝트\n- **API 요청**: 무제한\n- 개인 프로젝트 및 소규모 앱에 적합\n\n**Pro (프로 플랜)**:\n\n- **월 $25**: 더 많은 리소스와 기능\n- **데이터베이스**: 8GB 저장, 250GB 대역폭\n- **Storage**: 100GB 저장, 200GB 전송\n- **Edge Functions**: 월 2,000,000회 호출\n- **프로젝트**: 무제한\n- **우선 지원**: 우선 고객 지원\n- **일일 백업**: 자동 일일 백업\n\n**Team (팀 플랜)**:\n\n- **월 $599**: 팀 협업 기능\n- **데이터베이스**: 50GB 저장, 1TB 대역폭\n- **Storage**: 1TB 저장, 2TB 전송\n- **팀 협업**: 팀 멤버 관리\n- **SLA**: 99.95% 가동 시간 보장\n- **전담 지원**: 전담 고객 지원\n\n**개인 사용자 권장**:\n\n- 대부분의 개인 프로젝트는 **Free 플랜(무료)**으로 충분합니다\n- 500MB 데이터베이스와 1GB 스토리지로 충분한 기능 사용 가능\n- 무제한 인증 사용자와 API 요청으로 제약 없이 개발 가능\n- 프로젝트가 성장하면 Pro 플랜으로 업그레이드 가능\n\n### Supabase의 장점\n\n**기술적 장점**:\n\n- **오픈소스**: 완전 오픈소스로 자체 호스팅 가능, 벤더 종속성 없음\n- **PostgreSQL**: 업계 표준 강력한 관계형 데이터베이스 활용\n- **SQL 사용**: 기존 SQL 지식 활용 가능, 표준 쿼리 언어 사용\n- **데이터 무결성**: 제약 조건, 외래 키로 데이터 품질 보장\n- **복잡한 쿼리**: JOIN, 집계 함수 등 강력한 데이터 조회 기능\n- **트랜잭션**: ACID 속성으로 안전한 데이터 처리\n\n**기능적 장점**:\n\n- **실시간 기능**: 데이터베이스 변경사항 실시간 구독 지원\n- **자동 API**: RESTful API 자동 생성, 별도 백엔드 개발 불필요\n- **대시보드**: 직관적인 웹 대시보드로 데이터 관리\n- **인증 통합**: 인증과 데이터베이스가 완벽하게 통합\n- **스토리지**: 파일 저장 기능 내장\n- **Edge Functions**: 서버리스 함수로 비즈니스 로직 구현\n\n**비용 및 접근성**:\n\n- **무료 시작**: 무료 플랜으로 충분히 시작 가능\n- **합리적 가격**: Pro 플랜도 월 $25로 합리적\n- **학습 자료**: 풍부한 문서와 커뮤니티 지원\n- **이식성**: PostgreSQL 기반으로 다른 플랫폼으로 이전 가능\n\n### Supabase의 단점\n\n**기술적 제약**:\n\n- **SQL 학습 필요**: SQL을 모르면 학습이 필요함\n- **복잡한 설계**: 관계형 데이터베이스 설계가 초보자에게 어려울 수 있음\n- **확장성 제한**: 매우 대규모 트래픽에서는 NoSQL보다 제한적\n- **수평 확장**: 여러 서버에 분산하기 어려움 (수직 확장 필요)\n\n**기능적 제약**:\n\n- **서비스 통합**: Firebase보다 통합 서비스가 적음 (Analytics, Crashlytics 등)\n- **모바일 SDK**: 모바일 앱 개발 시 Firebase보다 제한적\n- **학습 곡선**: 초보자에게는 NoSQL보다 학습 곡선이 가파를 수 있음\n\n**비즈니스 제약**:\n\n- **상대적으로 신생**: Firebase보다 역사가 짧아 생태계가 작을 수 있음\n- **기업 지원**: 대기업 수준의 엔터프라이즈 지원은 제한적\n\n**언제 Supabase를 선택해야 할까?**:\n\n- **SQL을 알고 있거나 배우고 싶을 때**\n- **복잡한 데이터 관계가 필요할 때**\n- **데이터 무결성이 중요할 때**\n- **오픈소스를 선호할 때**\n- **웹 앱 개발에 집중할 때**\n- **PostgreSQL의 강력한 기능이 필요할 때**\n\n### Firebase vs Supabase\n\n**Firebase**:\n\n- NoSQL 데이터베이스 (Firestore)\n- 구글 인프라 기반\n- 더 많은 통합 서비스 (Analytics, Crashlytics 등)\n- 모바일 앱에 특화\n\n**Supabase**:\n\n- PostgreSQL (관계형 데이터베이스)\n- 오픈소스\n- SQL 사용 가능\n- 웹 앱에 특화\n- 더 유연한 데이터 구조\n\n**선택 가이드**:\n\n- **Firebase 선택**: NoSQL이 필요하고, 모바일 앱 개발 시\n- **Supabase 선택**: SQL을 사용하고 싶고, 관계형 데이터가 필요할 때'
          }
        ]
      },
      {
        id: '1-5',
        title: '저장과 배포',
        subSubChapters: [
          {
            id: '1-5-(1)',
            title: '(1) 저장 (GitHub)',
            content: '### GitHub란?\n\nGitHub는 코드를 저장하고 관리하는 클라우드 기반 플랫폼입니다. 전 세계 수백만 명의 개발자가 사용하는 가장 인기 있는 코드 저장소입니다.\n\n**GitHub의 주요 기능**:\n\n- **코드 저장소**: 프로젝트 코드를 클라우드에 안전하게 저장\n- **버전 관리**: Git을 통한 코드 변경 이력 추적\n- **협업**: 여러 사람이 함께 작업하고 코드 리뷰\n- **이슈 관리**: 버그 추적 및 기능 요청 관리\n- **프로젝트 공개**: 오픈소스 프로젝트 공유 및 기여\n\n### GitHub 계정 만들기\n\n1. **웹사이트 방문**: [github.com](https://github.com/)\n\n2. **회원가입**:\n   - "Sign up" 버튼 클릭\n   - 사용자 이름, 이메일, 비밀번호 입력\n   - 이메일 인증 완료\n\n3. **플랜 선택**:\n   - 무료 플랜으로 시작 가능\n   - 개인 프로젝트는 무료 플랜으로 충분\n\n### GitHub 요금제\n\n**Free (무료)**:\n\n- **개인 계정**: 완전 무료\n- **무제한 공개 저장소**: Public 저장소 무제한 생성\n- **무제한 Private 저장소**: Private 저장소도 무제한 생성\n- **협업자**: Private 저장소에 협업자 무제한 추가\n- **이슈 및 Pull Request**: 무제한 사용\n- **GitHub Actions**: 월 2,000분 무료 (빌드 및 배포 자동화)\n- **GitHub Packages**: 500MB 저장 공간\n- **커뮤니티 지원**: GitHub 커뮤니티 포럼 지원\n\n**Team (팀 플랜)**:\n\n- **월 $4/사용자**: 팀 협업 기능 강화\n- **고급 코드 리뷰**: 코드 리뷰 도구\n- **프로젝트 관리**: 고급 프로젝트 관리 기능\n- **보안 기능**: 보안 취약점 스캔\n- **우선 지원**: 우선 고객 지원\n\n**Enterprise (기업 플랜)**:\n\n- **기업용 기능**: 대규모 조직을 위한 기능\n- **고급 보안**: 엔터프라이즈급 보안 및 규정 준수\n- **전담 지원**: 24/7 전담 지원\n- **맞춤 가격**: 기업 규모에 따라 가격 협의\n\n**개인 사용자 권장**:\n\n- 대부분의 개인 개발자와 소규모 프로젝트는 **Free 플랜**으로 충분합니다\n- 무제한 저장소와 협업 기능을 무료로 사용 가능\n- GitHub Actions도 월 2,000분으로 충분한 양 제공\n\n### 저장소(Repository) 만들기\n\n1. **새 저장소 생성**:\n   - GitHub 로그인 후 우측 상단 "+" 아이콘 클릭\n   - "New repository" 선택\n\n2. **저장소 설정**:\n   - Repository name: 프로젝트 이름 입력\n   - Description: 프로젝트 설명 (선택사항)\n   - Public/Private 선택\n   - "Initialize this repository with a README" 체크 (선택사항)\n   - "Create repository" 클릭\n\n### 로컬 프로젝트를 GitHub에 연결하기\n\n1. **로컬에서 Git 초기화** (아직 안 했다면):\n   - 프로젝트 폴더에서 터미널 열기\n   - `git init` 실행\n\n2. **GitHub 액세스 토큰 생성** (필수):\n\n   GitHub에 푸시하려면 액세스 토큰이 반드시 필요합니다. 비밀번호만으로는 연결할 수 없습니다.\n\n   **단계별 토큰 생성 가이드**:\n\n   **1단계: GitHub 설정 페이지 접속**\n\n   - GitHub 웹사이트에 로그인\n   - 우측 상단 프로필 아이콘 클릭 (원형 아이콘)\n   - 드롭다운 메뉴에서 "Settings" 클릭\n\n   **2단계: Developer settings 접속**\n\n   - 왼쪽 사이드바 맨 아래로 스크롤\n   - "Developer settings" 클릭\n   - 새로운 페이지로 이동\n\n   **3단계: Personal access tokens 메뉴 선택**\n\n   - 왼쪽 메뉴에서 "Personal access tokens" 클릭\n   - "Tokens (classic)" 선택\n   - 기존 토큰 목록이 표시됨 (처음이면 비어있음)\n\n   **4단계: 새 토큰 생성 시작**\n\n   - 우측 상단 "Generate new token" 버튼 클릭\n   - "Generate new token (classic)" 선택\n   - GitHub 비밀번호 입력 요청 시 비밀번호 입력\n\n   **5단계: 토큰 설정**\n\n   - **Note (토큰 이름)**: 토큰을 구분하기 위한 이름 입력\n     - 예시: "내 컴퓨터", "노트북", "개발용 토큰" 등\n     - 나중에 어떤 기기에서 사용하는 토큰인지 알 수 있도록 명확하게 작성\n\n   - **Expiration (만료 기간)**: 토큰이 유효한 기간 선택\n     - 30 days: 30일 후 만료\n     - 60 days: 60일 후 만료\n     - 90 days: 90일 후 만료\n     - No expiration: 만료 없음 (권장하지 않음, 보안상 위험)\n     - 처음 사용자는 90 days 권장\n\n   **6단계: 권한(Scopes) 설정**\n\n   - 아래로 스크롤하여 권한 선택\n   - **필수 권한**: `repo` 체크\n     - repo: 전체 저장소 접근 권한 (읽기, 쓰기, 삭제 등)\n     - 이 권한이 있어야 코드를 푸시할 수 있음\n   - 다른 권한은 필요에 따라 선택 (일반적으로 repo만으로 충분)\n\n   **7단계: 토큰 생성 및 복사**\n\n   - 페이지 맨 아래 "Generate token" 버튼 클릭\n   - **중요**: 생성된 토큰이 한 번만 표시됨!\n   - 토큰은 `ghp_`로 시작하는 긴 문자열\n   - 즉시 복사하여 안전한 곳에 보관\n   - 예시: `ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx`\n   - 이 페이지를 벗어나면 다시 볼 수 없으므로 반드시 복사해두기\n\n   **토큰 보관 방법**:\n\n   - 메모장이나 비밀번호 관리 앱에 저장\n   - 파일로 저장할 경우 안전한 위치에 보관\n   - 다른 사람과 공유하지 않기\n   - GitHub에 커밋하지 않기 (`.gitignore`에 추가)\n\n3. **GitHub 저장소와 연결**:\n   - GitHub에서 생성한 저장소의 주소 복사\n   - `git remote add origin <저장소 주소>` 실행\n   - 예시: `git remote add origin https://github.com/사용자명/프로젝트명.git`\n\n4. **코드 업로드**:\n   - `git add .` (모든 파일 추가)\n   - `git commit -m "첫 커밋"` (커밋 생성)\n   - `git push -u origin main` (GitHub에 푸시)\n\n**액세스 토큰 보안 주의사항**:\n\n- **토큰은 비밀번호처럼 취급**: 절대 다른 사람과 공유하지 않기\n- **토큰 유출 시**: 즉시 GitHub에서 토큰 삭제하고 새로 생성\n- **토큰 분실 시**: 새로 생성해야 하며, 기존 토큰은 사용 불가\n- **토큰 관리**: 사용하지 않는 토큰은 정기적으로 삭제\n- **토큰 확인**: Settings > Developer settings > Personal access tokens에서 생성한 토큰 목록 확인 가능\n\n### GitHub의 장점\n\n- **무료 저장 공간**: 개인 프로젝트 무제한 저장\n- **버전 관리**: 모든 변경사항 추적 가능\n- **백업**: 코드가 안전하게 보관됨\n- **협업 도구**: 팀 프로젝트에 최적화\n- **포트폴리오**: GitHub 프로필로 개발 실력 어필 가능\n\n### 유용한 팁\n\n- **README.md 작성**: 프로젝트 설명, 설치 방법, 사용법 등 작성\n- **.gitignore 사용**: 불필요한 파일(노드 모듈, 빌드 파일 등) 제외\n- **커밋 메시지 명확하게**: 나중에 이해하기 쉽도록 작성\n- **브랜치 활용**: 기능별로 브랜치를 만들어 체계적으로 관리'
          },
          {
            id: '1-5-(2)',
            title: '(2) 배포 (Vercel)',
            content: '### Vercel이란?\n\nVercel은 웹 애플리케이션을 쉽고 빠르게 배포할 수 있는 플랫폼입니다. 특히 Next.js, React, Vue 등 현대적인 웹 프레임워크와 완벽하게 통합됩니다.\n\n**Vercel의 주요 특징**:\n\n- **무료 배포**: 개인 프로젝트 무료로 배포 가능\n- **자동 배포**: GitHub와 연결하면 코드 푸시 시 자동 배포\n- **빠른 속도**: 전 세계 CDN을 통한 빠른 로딩 속도\n- **HTTPS 자동**: SSL 인증서 자동 설정\n- **커스텀 도메인**: 자신의 도메인 연결 가능\n\n### Vercel 계정 만들기\n\n1. **웹사이트 방문**: [vercel.com](https://vercel.com/)\n\n2. **회원가입**:\n   - "Sign Up" 버튼 클릭\n   - GitHub 계정으로 로그인 권장 (가장 간편)\n   - 또는 이메일로 가입\n\n3. **플랜 선택**:\n   - Hobby 플랜(무료)으로 시작\n   - 개인 프로젝트는 무료 플랜으로 충분\n\n### Vercel 요금제\n\n**Hobby (무료)**:\n\n- **무료 배포**: 개인 프로젝트 무제한 배포\n- **대역폭**: 월 100GB 무료\n- **빌드 시간**: 월 6,000분 무료\n- **프리뷰 배포**: Pull Request마다 프리뷰 URL 생성\n- **HTTPS**: 자동 SSL 인증서\n- **커스텀 도메인**: 무제한 커스텀 도메인 연결\n- **환경 변수**: 무제한 환경 변수\n- **Vercel Analytics**: 기본 분석 도구\n- **커뮤니티 지원**: Vercel 커뮤니티 포럼 지원\n\n**Pro (프로 플랜)**:\n\n- **월 $20/사용자**: 팀 협업 및 고급 기능\n- **대역폭**: 월 1TB\n- **빌드 시간**: 월 24,000분\n- **팀 협업**: 팀 멤버 초대 및 권한 관리\n- **고급 분석**: Vercel Analytics Pro\n- **우선 지원**: 우선 고객 지원\n- **비밀 관리**: 고급 비밀 관리 기능\n- **로그 보존**: 더 긴 로그 보존 기간\n\n**Enterprise (기업 플랜)**:\n\n- **맞춤 가격**: 기업 규모에 따라 가격 협의\n- **무제한 대역폭**: 대역폭 제한 없음\n- **무제한 빌드**: 빌드 시간 제한 없음\n- **전담 지원**: 24/7 전담 지원\n- **SLA 보장**: 서비스 수준 협약\n- **고급 보안**: 엔터프라이즈급 보안 기능\n- **맞춤 설정**: 기업 요구사항에 맞는 맞춤 설정\n\n**개인 사용자 권장**:\n\n- 대부분의 개인 개발자와 소규모 프로젝트는 **Hobby 플랜(무료)**으로 충분합니다\n- 무제한 배포와 월 100GB 대역폭으로 충분한 양 제공\n- 커스텀 도메인도 무료로 연결 가능\n- 프로젝트가 성장하면 필요에 따라 Pro 플랜으로 업그레이드 가능\n\n### GitHub와 Vercel 연동하기\n\n**1단계: Vercel에 GitHub 계정 연결**\n\n1. **Vercel 대시보드 접속**:\n   - [vercel.com](https://vercel.com/)에 로그인\n   - 대시보드 메인 페이지로 이동\n\n2. **GitHub 연동 설정**:\n   - 우측 상단 프로필 아이콘 클릭\n   - "Settings" 선택\n   - 왼쪽 메뉴에서 "Git" 클릭\n   - "Connect Git Provider" 섹션에서 "GitHub" 선택\n   - GitHub 로그인 화면으로 이동\n   - GitHub 계정으로 로그인\n   - Vercel이 GitHub에 접근할 수 있도록 권한 승인\n   - "Authorize Vercel" 버튼 클릭\n\n3. **연동 확인**:\n   - Settings > Git 페이지에서 GitHub가 연결되어 있는지 확인\n   - 연결된 GitHub 계정 이름이 표시됨\n\n**2단계: GitHub 저장소를 Vercel에 연결**\n\n1. **새 프로젝트 추가**:\n   - Vercel 대시보드에서 "Add New..." 버튼 클릭\n   - "Project" 선택\n\n2. **GitHub 저장소 선택**:\n   - "Import Git Repository" 화면에서 GitHub 저장소 목록 확인\n   - 배포할 저장소 검색 또는 선택\n   - 저장소가 보이지 않으면 "Adjust GitHub App Permissions" 클릭하여 권한 확인\n\n3. **저장소 권한 설정** (필요한 경우):\n   - 특정 저장소만 보이지 않으면:\n     - GitHub에서 Settings > Applications > Authorized OAuth Apps\n     - Vercel 선택\n     - 저장소 접근 권한 확인 및 수정\n\n### 프로젝트 배포 설정\n\n**1단계: 프로젝트 기본 설정**\n\n1. **프로젝트 이름 설정**:\n   - Project Name: 프로젝트 이름 입력 (자동으로 저장소 이름이 입력됨)\n   - 원하는 이름으로 변경 가능\n\n2. **프레임워크 설정**:\n   - Framework Preset: 자동으로 감지됨\n   - Next.js, React, Vue, Angular 등 자동 인식\n   - 수동으로 변경 가능\n\n3. **루트 디렉토리 설정**:\n   - Root Directory: 프로젝트 루트 경로\n   - 모노레포인 경우 서브 디렉토리 경로 입력\n   - 일반적으로 그대로 두면 됨\n\n**2단계: 빌드 설정**\n\n1. **빌드 명령어**:\n   - Build Command: 자동으로 설정됨\n   - Next.js: `next build`\n   - React: `npm run build` 또는 `yarn build`\n   - 필요시 수동으로 변경 가능\n\n2. **출력 디렉토리**:\n   - Output Directory: 빌드 결과물이 생성되는 폴더\n   - Next.js: `.next` (자동 설정)\n   - React: `build` 또는 `dist`\n   - 자동 감지되므로 보통 변경 불필요\n\n3. **설치 명령어**:\n   - Install Command: 패키지 설치 명령어\n   - `npm install`, `yarn install`, `pnpm install` 등\n   - 자동으로 설정됨\n\n**3단계: 환경 변수 설정** (필요한 경우)\n\n1. **환경 변수 추가**:\n   - "Environment Variables" 섹션으로 이동\n   - Key와 Value 입력\n   - 예시:\n     - Key: `API_KEY`\n     - Value: `your-api-key-here`\n   - "Add" 버튼 클릭\n\n2. **환경별 설정**:\n   - Production: 프로덕션 환경에만 적용\n   - Preview: 프리뷰 환경에만 적용\n   - Development: 개발 환경에만 적용\n   - 모든 환경에 적용하려면 모두 체크\n\n**4단계: 배포 실행**\n\n1. **배포 시작**:\n   - 모든 설정 완료 후 "Deploy" 버튼 클릭\n   - 배포 프로세스 시작\n\n2. **배포 진행 상황 확인**:\n   - 배포 로그가 실시간으로 표시됨\n   - Installing dependencies (의존성 설치)\n   - Building (빌드 중)\n   - Deploying (배포 중)\n\n3. **배포 완료**:\n   - 몇 분 내 배포 완료\n   - "Visit" 버튼으로 배포된 사이트 확인\n   - 배포된 URL 확인 (예: `프로젝트명.vercel.app`)\n\n### 자동 배포 설정\n\nGitHub와 Vercel을 연동하면 자동 배포가 기본적으로 활성화됩니다.\n\n**자동 배포 동작 방식**:\n\n1. **프로덕션 배포 (Production)**:\n   - main 브랜치 (또는 master 브랜치)에 코드를 푸시하면 자동 배포\n   - `git push origin main` 실행 시 자동으로 배포 시작\n   - 배포 완료 후 프로덕션 URL로 접속 가능\n\n2. **프리뷰 배포 (Preview)**:\n   - 다른 브랜치에 푸시하면 프리뷰 배포 생성\n   - Pull Request 생성 시 자동으로 프리뷰 URL 생성\n   - 각 브랜치마다 고유한 프리뷰 URL 제공\n   - 예시: `프로젝트명-git-브랜치명-사용자명.vercel.app`\n\n3. **자동 배포 확인**:\n   - Vercel 대시보드에서 "Deployments" 탭 확인\n   - 모든 배포 이력 확인 가능\n   - 각 배포의 상태, 시간, 커밋 메시지 확인\n\n**자동 배포 설정 확인 및 변경**:\n\n1. **프로젝트 설정 접속**:\n   - Vercel 대시보드에서 프로젝트 선택\n   - "Settings" 탭 클릭\n   - "Git" 섹션 선택\n\n2. **프로덕션 브랜치 설정**:\n   - Production Branch: 프로덕션 배포할 브랜치 선택\n   - 기본값: `main` 또는 `master`\n   - 원하는 브랜치로 변경 가능\n\n3. **자동 배포 활성화/비활성화**:\n   - Settings > Git 페이지에서 "Deploy Hooks" 섹션 확인\n   - 또는 "Git" 섹션 하단에 "Automatic deployments from Git" 옵션 확인\n   - 정확한 경로:\n     1. Vercel 대시보드 접속\n     2. 배포할 프로젝트 클릭\n     3. 상단 메뉴에서 "Settings" 탭 클릭\n     4. 왼쪽 사이드바에서 "Git" 메뉴 클릭\n     5. "Git" 페이지에서 "Automatic deployments from Git" 체크박스 확인\n   - 체크 해제 시 수동 배포만 가능 (GitHub 푸시해도 자동 배포 안 됨)\n   - 일반적으로 활성화 상태 유지 권장\n\n4. **프리뷰 배포 설정**:\n   - "Automatic Preview deployments" 옵션\n   - Pull Request 생성 시 자동 프리뷰 배포\n   - 체크 해제 시 프리뷰 배포 비활성화\n\n**자동 배포 활용 팁**:\n\n- **커밋 메시지 확인**: 각 배포는 커밋 메시지와 연결되어 추적 가능\n- **롤백 기능**: 이전 배포로 쉽게 되돌리기 가능\n- **배포 알림**: 이메일 또는 Slack으로 배포 상태 알림 받기 가능\n- **배포 웹훅**: 외부 서비스와 연동하여 배포 이벤트 처리 가능\n\n### 배포 후 확인사항\n\n1. **배포 상태 확인**:\n   - Vercel 대시보드에서 배포 상태 확인\n   - 성공/실패 여부 확인\n\n2. **사이트 접속**:\n   - 제공된 URL로 접속 테스트\n   - 모든 기능이 정상 작동하는지 확인\n\n3. **도메인 설정** (선택사항):\n   - Settings > Domains에서 커스텀 도메인 추가\n   - DNS 설정 후 연결\n\n### Vercel의 장점\n\n- **간편한 배포**: 몇 번의 클릭으로 배포 완료\n- **무료 플랜**: 개인 프로젝트 무료 사용\n- **빠른 성능**: 전 세계 CDN으로 빠른 로딩\n- **자동 HTTPS**: 보안 연결 자동 설정\n- **실시간 로그**: 배포 및 실행 로그 확인 가능\n\n### 유용한 팁\n\n- **환경 변수 관리**: 민감한 정보는 환경 변수로 설정\n- **빌드 오류 확인**: 배포 실패 시 로그 확인하여 문제 해결\n- **프리뷰 활용**: Pull Request로 변경사항 미리 확인\n- **성능 모니터링**: Analytics로 사이트 성능 추적\n- **도메인 연결**: 무료 도메인 서비스와 연동 가능'
          }
        ]
      }
    ]
  }
]

export function Book() {
  // 초기 선택: 첫 번째 subChapter에 content가 있으면 그것을, 없으면 첫 번째 subSubChapter를 선택
  const getInitialSelection = () => {
    const firstSubChapter = chapters[0].subChapters[0]
    if (firstSubChapter.content) {
      return firstSubChapter.id
    }
    if (firstSubChapter.subSubChapters && firstSubChapter.subSubChapters.length > 0) {
      return firstSubChapter.subSubChapters[0].id
    }
    return firstSubChapter.id
  }

  const [selectedSubChapter, setSelectedSubChapter] = useState<string>(getInitialSelection())
  const [expandedSubChapters, setExpandedSubChapters] = useState<Set<string>>(() => {
    const initialExpanded = new Set<string>()
    // If the initially selected sub-chapter has sub-sub-chapters, expand it
    const defaultSubChapter = chapters[0].subChapters[0]
    if (defaultSubChapter.subSubChapters && defaultSubChapter.subSubChapters.length > 0) {
      initialExpanded.add(defaultSubChapter.id)
    }
    return initialExpanded
  })

  // 현재 선택된 항목 찾기 (subChapter 또는 subSubChapter)
  const findCurrentContent = () => {
    for (const chapter of chapters) {
      for (const subChapter of chapter.subChapters) {
        if (subChapter.id === selectedSubChapter) {
          if (subChapter.content) {
            return { title: subChapter.title, content: subChapter.content }
          }
          // If a sub-chapter with sub-sub-chapters is selected, but it has no direct content,
          // return the first sub-sub-chapter's content if available.
          if (subChapter.subSubChapters && subChapter.subSubChapters.length > 0) {
            return { title: subChapter.subSubChapters[0].title, content: subChapter.subSubChapters[0].content || '' }
          }
        }
        if (subChapter.subSubChapters) {
          for (const subSubChapter of subChapter.subSubChapters) {
            if (subSubChapter.id === selectedSubChapter) {
              return { title: subSubChapter.title, content: subSubChapter.content }
            }
          }
        }
      }
    }
    // Fallback to the very first content if nothing is selected or found
    const defaultSubChapter = chapters[0].subChapters[0];
    if (defaultSubChapter.subSubChapters && defaultSubChapter.subSubChapters.length > 0) {
      return { title: defaultSubChapter.subSubChapters[0].title, content: defaultSubChapter.subSubChapters[0].content || '' };
    }
    return { title: defaultSubChapter.title, content: defaultSubChapter.content || '' };
  }

  const currentContent = findCurrentContent()

  const toggleSubChapter = (subChapterId: string) => {
    setExpandedSubChapters(prev => {
      const newSet = new Set(prev)
      if (newSet.has(subChapterId)) {
        newSet.delete(subChapterId)
      } else {
        newSet.add(subChapterId)
      }
      return newSet
    })
  }

  // 링크 파싱 헬퍼 함수 (마크다운 링크 + 일반 URL 모두 처리)
  const parseLinks = (text: string) => {
    if (!text) return [text]
    
    const parts: (string | JSX.Element)[] = []
    let key = 0
    let lastIndex = 0
    
    // 모든 매치 수집 (마크다운 링크와 일반 URL)
    const matches: Array<{start: number, end: number, type: 'markdown' | 'url', text?: string, url: string}> = []
    
    // 마크다운 링크 [text](url)
    const markdownRegex = /\[([^\]]+)\]\(([^)]+)\)/g
    let markdownMatch: RegExpExecArray | null
    while ((markdownMatch = markdownRegex.exec(text)) !== null) {
      if (markdownMatch.index !== undefined) {
        matches.push({
          start: markdownMatch.index,
          end: markdownMatch.index + markdownMatch[0].length,
          type: 'markdown',
          text: markdownMatch[1],
          url: markdownMatch[2]
        })
      }
    }
    
    // 일반 URL 패턴 (http://, https://, 또는 도메인.확장자 형식)
    const urlRegex = /(https?:\/\/[^\s\)]+|(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(?:\/[^\s\)]*)?)/g
    let urlMatch: RegExpExecArray | null
    while ((urlMatch = urlRegex.exec(text)) !== null) {
      if (urlMatch.index !== undefined) {
        const urlMatchIndex = urlMatch.index
        // 마크다운 링크 안에 있는 URL은 건너뛰기
        const isInsideMarkdown = matches.some(m => 
          m.type === 'markdown' && urlMatchIndex >= m.start && urlMatchIndex < m.end
        )
        if (!isInsideMarkdown) {
          matches.push({
            start: urlMatchIndex,
            end: urlMatchIndex + urlMatch[0].length,
            type: 'url',
            url: urlMatch[0]
          })
        }
      }
    }
    
    // 시작 위치로 정렬
    matches.sort((a, b) => a.start - b.start)
    
    // 중복 제거 (겹치는 부분 제거)
    const filteredMatches: typeof matches = []
    matches.forEach(m => {
      const overlaps = filteredMatches.some(fm => 
        (m.start >= fm.start && m.start < fm.end) || 
        (m.end > fm.start && m.end <= fm.end)
      )
      if (!overlaps) {
        filteredMatches.push(m)
      }
    })
    
    // 텍스트를 파싱하여 링크 생성
    filteredMatches.forEach(m => {
      if (m.start > lastIndex) {
        parts.push(text.substring(lastIndex, m.start))
      }
      
      if (m.type === 'markdown') {
        parts.push(
          <a 
            key={key++} 
            href={m.url} 
            target="_blank" 
            rel="noopener noreferrer"
            className="text-indigo-600 hover:text-indigo-800 underline"
          >
            {m.text}
          </a>
        )
      } else {
        const url = m.url.startsWith('http') ? m.url : `https://${m.url}`
        parts.push(
          <a 
            key={key++} 
            href={url} 
            target="_blank" 
            rel="noopener noreferrer"
            className="text-indigo-600 hover:text-indigo-800 underline"
          >
            {m.url}
          </a>
        )
      }
      lastIndex = m.end
    })
    
    if (lastIndex < text.length) {
      parts.push(text.substring(lastIndex))
    }
    
    return parts.length > 0 ? parts : [text]
  }

  return (
    <section id="ebook" className="relative w-full min-h-screen bg-gradient-to-b from-gray-50 to-white py-20">
      <div className="max-w-7xl mx-auto px-5">
        <h2 className="text-4xl font-bold text-center mb-16 text-gray-900">
          전자책
        </h2>
        
        <div className="flex flex-col md:flex-row gap-8">
          {/* 왼쪽 목차 */}
          <div className="w-full md:w-1/3 lg:w-1/4">
            <div className="bg-white rounded-lg shadow-lg p-6 sticky top-24">
              <h3 className="text-xl font-bold mb-4 text-gray-900">목차</h3>
              <nav className="space-y-1">
                {chapters.map((chapter) => (
                  <div key={chapter.id} className="mb-2">
                    <div className="text-sm font-semibold text-gray-500 mb-1 px-2">
                      {chapter.id}. {chapter.title}
                    </div>
                    <div className="space-y-1 ml-2">
                      {chapter.subChapters.map((subChapter) => {
                        const hasSubSubChapters = subChapter.subSubChapters && subChapter.subSubChapters.length > 0
                        const isExpanded = expandedSubChapters.has(subChapter.id)
                        
                        return (
                          <div key={subChapter.id}>
                            <button
                              onClick={(e) => {
                                e.preventDefault()
                                e.stopPropagation()
                                if (hasSubSubChapters) {
                                  const newExpanded = !isExpanded
                                  toggleSubChapter(subChapter.id)
                                  if (newExpanded && subChapter.subSubChapters && subChapter.subSubChapters.length > 0) {
                                    setSelectedSubChapter(subChapter.subSubChapters[0].id)
                                  }
                                } else {
                                  setSelectedSubChapter(subChapter.id)
                                }
                              }}
                              className={`w-full text-left px-4 py-2 rounded-lg transition-all text-sm ${
                                selectedSubChapter === subChapter.id && !hasSubSubChapters
                                  ? 'bg-indigo-600 text-white font-semibold'
                                  : hasSubSubChapters
                                  ? 'bg-gray-100 text-gray-700 hover:bg-gray-200 font-semibold'
                                  : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                              }`}
                            >
                              {subChapter.id} {subChapter.title}
                            </button>
                            {hasSubSubChapters && isExpanded && subChapter.subSubChapters && (
                              <div className="ml-4 mt-1 space-y-1">
                                {subChapter.subSubChapters.map((subSubChapter) => (
                                  <button
                                    key={subSubChapter.id}
                                    onClick={(e) => {
                                      e.preventDefault()
                                      e.stopPropagation()
                                      setSelectedSubChapter(subSubChapter.id)
                                    }}
                                    className={`w-full text-left px-4 py-2 rounded-lg transition-all text-xs ${
                                      selectedSubChapter === subSubChapter.id
                                        ? 'bg-indigo-600 text-white font-semibold'
                                        : 'bg-gray-50 text-gray-600 hover:bg-gray-200'
                                    }`}
                                  >
                                    {subSubChapter.title}
                                  </button>
                                ))}
                              </div>
                            )}
                          </div>
                        )
                      })}
                    </div>
                  </div>
                ))}
              </nav>
            </div>
          </div>

          {/* 오른쪽 내용 */}
          <div className="flex-1">
            <div className="bg-white rounded-lg shadow-lg p-8 md:p-12 min-h-[600px]">
              <h3 className="text-3xl md:text-4xl font-bold mb-6 text-gray-900">
                {currentContent.title}
              </h3>
              <div className="prose prose-lg max-w-none">
                <div className="text-lg md:text-xl text-gray-700 leading-relaxed space-y-4">
                  {(() => {
                    const paragraphs = currentContent.content.split('\n\n')
                    const elements: JSX.Element[] = []
                    let i = 0
                    let elementIndex = 0
                    
                    while (i < paragraphs.length) {
                      const paragraph = paragraphs[i]
                      
                      // 구분선 처리
                      if (paragraph.trim() === '---') {
                        elements.push(<hr key={elementIndex++} className="my-6 border-gray-300" />)
                        i++
                        continue
                      }
                      
                      // 제목 처리 (###) - 최우선 처리
                      const trimmedPara = paragraph.trim()
                      if (trimmedPara.startsWith('### ')) {
                        const title = trimmedPara.replace(/^###\s+/, '')
                        elements.push(
                          <h3 key={elementIndex++} className="text-2xl md:text-3xl font-bold text-gray-900 mt-8 mb-4">
                            {title.split('**').map((text, idx) => {
                              const content = idx % 2 === 1 ? (
                                <strong key={idx}>{text}</strong>
                              ) : (
                                parseLinks(text)
                              )
                              return <span key={idx}>{content}</span>
                            })}
                          </h3>
                        )
                        i++
                        continue
                      }
                      
                      // 리스트 처리 (-)
                      if (paragraph.trim().startsWith('- ')) {
                        const listItems = paragraph.split('\n').filter(line => line.trim().startsWith('- '))
                        elements.push(
                          <ul key={elementIndex++} className="list-disc list-inside space-y-2 ml-4">
                            {listItems.map((item, itemIndex) => {
                              const cleanItem = item.replace(/^-\s*/, '')
                              return (
                                <li key={itemIndex} className="leading-relaxed">
                                  {cleanItem.split('**').map((text, idx) => {
                                    const content = idx % 2 === 1 ? (
                                      <strong key={idx} className="font-bold text-gray-900">{text}</strong>
                                    ) : (
                                      parseLinks(text)
                                    )
                                    return <span key={idx}>{content}</span>
                                  })}
                                </li>
                              )
                            })}
                          </ul>
                        )
                        i++
                        continue
                      }
                      
                      // 번호 리스트 처리 (1. 2. 등) - 연속된 번호 리스트를 하나로 묶기
                      if (/^\d+\.\s/.test(paragraph.trim())) {
                        const listItems: { number: string, content: string }[] = []
                        let currentIndex = i
                        
                        // 연속된 번호 리스트 아이템들을 수집
                        while (currentIndex < paragraphs.length) {
                          const currentPara = paragraphs[currentIndex]
                          
                          // 제목이 나오면 리스트 중단
                          if (currentPara.startsWith('### ')) {
                            break
                          }
                          
                          const lines = currentPara.split('\n')
                          const numberedLines = lines.filter(line => /^\d+\.\s/.test(line.trim()))
                          
                          if (numberedLines.length > 0) {
                            // 첫 번째 번호 라인 찾기
                            const firstNumberedLine = numberedLines[0]
                            const match = firstNumberedLine.trim().match(/^(\d+)\.\s(.+)$/)
                            if (match) {
                              const number = match[1]
                              const restOfLine = match[2]
                              
                              // 이 번호 라인 이후의 모든 내용 수집 (다음 번호 라인 전까지)
                              let content = restOfLine
                              let lineIndex = lines.indexOf(firstNumberedLine) + 1
                              
                              // 같은 문단 내에서 다음 번호 라인 전까지의 내용 수집
                              while (lineIndex < lines.length && !/^\d+\.\s/.test(lines[lineIndex].trim())) {
                                content += '\n' + lines[lineIndex]
                                lineIndex++
                              }
                              
                              // 다음 문단들도 확인 (다음 번호 라인 또는 제목이 나올 때까지)
                              let nextParaIndex = currentIndex + 1
                              while (nextParaIndex < paragraphs.length) {
                                const nextPara = paragraphs[nextParaIndex]
                                // 제목이 나오면 중단
                                if (nextPara.startsWith('### ')) {
                                  break
                                }
                                if (/^\d+\.\s/.test(nextPara.trim())) {
                                  break
                                }
                                content += '\n\n' + nextPara
                                nextParaIndex++
                              }
                              
                              listItems.push({ number, content: content.trim() })
                              currentIndex = nextParaIndex
                            } else {
                              currentIndex++
                            }
                          } else {
                            break
                          }
                        }
                        
                        if (listItems.length > 0) {
                          elements.push(
                            <ol key={elementIndex++} className="list-decimal list-outside space-y-2 ml-6 pl-2">
                              {listItems.map((item, itemIndex) => {
                                // 첫 줄에서 제목 추출 (첫 줄이 제목, 나머지는 본문)
                                const contentLines = item.content.split('\n')
                                const firstLine = contentLines[0] || ''
                                const bodyLines = contentLines.slice(1)
                                
                                return (
                                  <li key={itemIndex} className="leading-relaxed">
                                    {/* 제목 부분 - 번호 옆에 인라인으로 표시 */}
                                    <span className="font-semibold text-gray-900">
                                      {firstLine.split('**').map((text, idx) => {
                                        const content = idx % 2 === 1 ? (
                                          <strong key={idx} className="font-bold">{text}</strong>
                                        ) : (
                                          parseLinks(text)
                                        )
                                        return <span key={idx}>{content}</span>
                                      })}
                                    </span>
                                    {/* 본문 부분 */}
                                    {bodyLines.length > 0 && (
                                      <div className="mt-2">
                                        {bodyLines.join('\n').split('\n\n').map((para, paraIdx) => (
                                          <div key={paraIdx} className={paraIdx > 0 ? 'mt-2' : ''}>
                                            {para.split('**').map((text, idx) => {
                                              const content = idx % 2 === 1 ? (
                                                <strong key={idx} className="font-bold text-gray-900">{text}</strong>
                                              ) : (
                                                parseLinks(text)
                                              )
                                              return <span key={idx}>{content}</span>
                                            })}
                                          </div>
                                        ))}
                                      </div>
                                    )}
                                  </li>
                                )
                              })}
                            </ol>
                          )
                          i = currentIndex
                          continue
                        }
                      }
                      
                      // 일반 문단
                      elements.push(
                        <p key={elementIndex++} className="whitespace-pre-line leading-relaxed">
                          {paragraph.split('**').map((text, idx) => {
                            const content = idx % 2 === 1 ? (
                              <strong key={idx} className="font-bold text-gray-900">{text}</strong>
                            ) : (
                              parseLinks(text)
                            )
                            return <span key={idx}>{content}</span>
                          })}
                        </p>
                      )
                      i++
                    }
                    
                    return elements
                  })()}
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  )
}